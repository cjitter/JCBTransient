
// =============================================================================
// PARÁMETROS DEL EXPANSOR
// =============================================================================

// Parámetros principales
Param a_TRIM(-12, min=-12, default=0, max=12);        // Input trim gain (dB)

Param b_ATTACK_GAIN(0, min=-18, default=0, max=18);   // Attack enhancement/reduction (dB)
Param c_SUSTAIN_GAIN(0, min=-18, default=0, max=18);  // Sustain enhancement/reduction (dB)

Param q_SENSITIVITY(0.5, min=0, default=0.5, max=1);  // Detection sensitivity (0-1)

Param d_ATK(0.1, min=0.1, default=1, max=250);
Param e_REL(1, min=1, default=10, max=500);
Param f_HOLD(0, min=0, default=0, max=500);

Param i_MAKEUP(-12, min=-12, default=0, max=12);      // Makeup gain (dB)
//Param h_RANGE(-20, min=-100, default=-20, max=0);      // Range width (dB) - para expansor

Param g_REACT(0, min=0, default=0, max=1);            // Peak/RMS mix (0=Peak, 1=RMS)
Param z_SMOOTH(0, min=0, default=0, max=1);           // Extra smoothing amount

// Filtros de sidechain
Param j_HPF(20, min=20, default=20, max=20000);       // Sidechain HPF frequency (Hz)
Param j_HPFORDER(0, min=0, default=0, max=1);         // HPF order (0=12dB/oct, 1=24dB/oct)

Param k_LPF(20, min=20, default=20000, max=20000);    // Sidechain LPF frequency (Hz)
Param k_LPFORDER(0, min=0, default=0, max=1);         // LPF order (0=12dB/oct, 1=24dB/oct)

Param l_SC(0, min=0, default=0, max=1);               // Sidechain filter enable
Param y_SCTRIM(-12, min=-12, default=0, max=12);      // Sidechain input trim (dB)

// Routing y mezcla
Param r_KEY(0, min=0, default=0, max=1);              // External key input mix
Param m_SOLOSC(0, min=0, default=0, max=1);           // Solo sidechain signal
Param o_DRYWET(0, min=0, default=1, max=1);           // Dry/Wet mix (0=Dry, 1=Wet)

Param v_DELTA(0, min=0, default=0, max=1);            // Delta mode (difference signal)
Param h_DELTAMODE(0, min=0, default=0, max=2);     // Delta Mode: 0=Attack, 1=Both, 2=Sustain

// Características avanzadas
Param n_LOOKAHEAD(0, min=0, default=0, max=10);       // Lookahead time (ms)

Param u_SOFTCLIP(0, min=0, default=0, max=1);         // Output saturation amount (0=Off, 1=Full)

// Control
Param p_BYPASS(0, min=0, default=0, max=1);           // Bypass switch

// =============================================================================
// HISTORIAS Y DELAYS
// =============================================================================

// Historias para detección de transientes (usadas en detectTransientEnhanced)
History envelopeHistory(0);           // Envolvente anterior
History transientSmoothHistory(0);    // Suavizado de detección
History diffHistory1(0);              // Para filtro diferenciador
History diffHistory2(0);              // Para suavizado diferenciador

// Historias para Transient Designer (NUEVAS)
History attackGainHistory(0);          // Para attack gain smoothing
History sustainGainHistory(0);         // Para sustain gain smoothing
History sensitivityHistory(0);         // Para sensitivity smoothing


History deltaModeHistory(0);           // Para delta mode amount
History makeupGainHistory(0);          // Para makeup gain amount
History soloSidechainHistory(0);       // Para solo sidechain amount
History bypassAmountHistory(0);        // Para bypass amount
History keyMixHistory(0);              // Para key input mix
History dryWetMixHistory(0);           // Para dry/wet mix
History trimHistory(0);                // Para input trim gain
History sidechainTrimHistory(0);       // Para sidechain trim gain
History rangeHistory(0);               // Para range width (en lugar de kneeHistory)
History reactHistory(0);              // Para peak/RMS mix
History smoothAmountHistory(0);       // Para extra smoothing
History lookaheadHistory(0);          // Para lookahead (con factor especial)
History hpfFreqHistory(0);            // Para HPF frequency
History lpfFreqHistory(0);            // Para LPF frequency
History scEnableHistory(0);           // Para sidechain filter enable
History softclipHistory(0);           // Para softclip amount
History atkHistory(0);                // Para attack time
History relHistory(0);                // Para release time

// Historias para filtros de sidechain
History lpfHistory1(0);                // LPF stage 1 input delay
History lpfHistory2(0);                // LPF stage 1 output delay z^-1
History lpfHistory3(0);                // LPF stage 1 input z^-1
History lpfHistory4(0);                // LPF stage 1 output z^-2
History lpfHistory5(0);                // LPF stage 2 input delay
History lpfHistory6(0);                // LPF stage 2 output delay z^-1
History lpfHistory7(0);                // LPF stage 2 input z^-1
History lpfHistory8(0);                // LPF stage 2 output z^-2
History hpfHistory1(0);                // HPF stage 1 output delay z^-1
History hpfHistory2(0);                // HPF stage 1 input delay
History hpfHistory3(0);                // HPF stage 1 input z^-1
History hpfHistory4(0);                // HPF stage 1 output z^-2
History hpfHistory5(0);                // HPF stage 2 output delay z^-1
History hpfHistory6(0);                // HPF stage 2 input delay
History hpfHistory7(0);                // HPF stage 2 input z^-1
History hpfHistory8(0);                // HPF stage 2 output z^-2

// Historias adicionales para filtros de sidechain (etapas 3 y 4)
History lpfHistory9(0);                // LPF stage 3 input delay
History lpfHistory10(0);               // LPF stage 3 output delay z^-1
History lpfHistory11(0);               // LPF stage 3 input z^-1
History lpfHistory12(0);               // LPF stage 3 output z^-2
History lpfHistory13(0);               // LPF stage 4 input delay
History lpfHistory14(0);               // LPF stage 4 output delay z^-1
History lpfHistory15(0);               // LPF stage 4 input z^-1
History lpfHistory16(0);               // LPF stage 4 output z^-2

History hpfHistory9(0);                // HPF stage 3 output delay z^-1
History hpfHistory10(0);               // HPF stage 3 input delay
History hpfHistory11(0);               // HPF stage 3 input z^-1
History hpfHistory12(0);               // HPF stage 3 output z^-2
History hpfHistory13(0);               // HPF stage 4 output delay z^-1
History hpfHistory14(0);               // HPF stage 4 input delay
History hpfHistory15(0);               // HPF stage 4 input z^-1
History hpfHistory16(0);               // HPF stage 4 output z^-2

// Historias para smoothing de orden de filtros
History hpfOrderHistory(0);            // Para suavizar cambio de orden HPF
History lpfOrderHistory(0);            // Para suavizar cambio de orden LPF

// Nueva historia para detección de transientes (auto-release simplificado)
//History transientDetector(0);          // Detector de transientes acumulado

// Delays de lookahead (25ms a 48kHz = 1200 muestras)
Delay leftOutputDelay(0.025*samplerate);   // Delay señal izquierda para compresión
Delay rightOutputDelay(0.025*samplerate);  // Delay señal derecha para compresión
Delay leftInputDelay(0.025*samplerate);    // Delay entrada izquierda para mezcla
Delay rightInputDelay(0.025*samplerate);   // Delay entrada derecha para mezcla
Delay sidechainTapDelay(0.025*samplerate); // Delay para tap de sidechain
Delay sidechainWriteDelay(0.025*samplerate); // Delay para escritura de sidechain

// =============================================================================
// VARIABLES DE DETECCIÓN DE ENVOLVENTE
// =============================================================================

// RMS Detection Buffer
Delay rmsDelay(500);                   // Circular buffer para cálculo RMS (500 muestras)
History rmsSum(0);                     // Suma acumulada para RMS

//History prevEnvelope(0);               // Envolvente anterior para auto-release

// Sharp Detector (Algoritmo 0) - Respuesta rápida
History peakEnvSharp(0);               // Detector de picos rápido
History releaseHistSharp(0);           // Historia de release para sharp
History attackHistSharp(0);            // Historia de attack para sharp
History extraSmoothHistSharp(0);       // Extra smoothing para sharp

// Gain Reduction Smoothing
History reductionHistLeft(0);          // Suavizado de gain reduction canal L
History reductionHistRight(0);         // Suavizado de gain reduction canal R

// Para el algoritmo Sharp
History held_peak_sharp(0);      // Nivel pico mantenido durante hold
History hold_counter_sharp(0);   // Contador de samples en hold

// =============================================================================
// VARIABLES DE SALIDA Y CONSTANTES
// =============================================================================

debug_transient_amount = 0;  // AGREGAR

// Variables globales para debug
debug_function_called = 0;
debug_envelope_linear = 0;
debug_total_gain = 0;

// Variables globales para debug
debug_diff_value = 0;
debug_transient_value = 0;

// VARIABLES GLOBALES PARA RETORNO DE FUNCIONES
new_diff_value = 0;
new_smooth_value = 0;

// Variables para almacenar las salidas procesadas
leftProcessedOutput = 0;               // Salida procesada canal izquierdo
rightProcessedOutput = 0;              // Salida procesada canal derecho

// Constantes para optimización y legibilidad
SMOOTH_HISTORY_FACTOR = 0.999;         // Factor de suavizado para valores históricos (99.9%)
SMOOTH_PARAM_FACTOR = 0.001;           // Factor de suavizado para nuevos parámetros (0.1%)
AUTO_MAKEUP_FACTOR = -0.7;             // Factor de compensación automática de ganancia
LOOKAHEAD_DELAY_SAMPLES = 0.025*samplerate; // Muestras de delay para lookahead
LOOKAHEAD_SMOOTH_FACTOR = 0.9999;      // Factor ultra lento para lookahead

// PROCESAMIENTO PRINCIPAL


// =============================================================================
// SMOOTHING DE PARÁMETROS - Filtro de primer orden para evitar clicks
// =============================================================================
// Implementación: y[n] = a * x[n] + (1-a) * y[n-1]
// Donde: a = SMOOTH_PARAM_FACTOR (0.001), (1-a) = SMOOTH_HISTORY_FACTOR (0.999)
// Resultado: Suavizado exponencial con tiempo de respuesta ~1000 muestras

// Parallel Mix Amount - Cantidad de compresión paralela

// Delta Mode Amount - Cantidad de señal diferencia (experimental)
smoothDeltaMode = (deltaModeHistory * SMOOTH_HISTORY_FACTOR) + (v_DELTA * SMOOTH_PARAM_FACTOR);
deltaModeHistoryNext = fixdenorm(smoothDeltaMode);

// Attack Gain Smoothing - Ganancia de transientes
smoothAttackGain = (attackGainHistory * SMOOTH_HISTORY_FACTOR) + (b_ATTACK_GAIN * SMOOTH_PARAM_FACTOR);
attackGainHistoryNext = fixdenorm(smoothAttackGain);

// Sustain Gain Smoothing - Ganancia de sustain
smoothSustainGain = (sustainGainHistory * SMOOTH_HISTORY_FACTOR) + (c_SUSTAIN_GAIN * SMOOTH_PARAM_FACTOR);
sustainGainHistoryNext = fixdenorm(smoothSustainGain);

// Sensitivity Smoothing - Sensibilidad de detección
smoothSensitivity = (sensitivityHistory * SMOOTH_HISTORY_FACTOR) + (q_SENSITIVITY * SMOOTH_PARAM_FACTOR);
sensitivityHistoryNext = fixdenorm(smoothSensitivity);

// =============================================================================
// IMPLEMENTACIÓN DELTA MODE - Bypass automático de procesamiento posterior
// =============================================================================
// Cuando DELTA está activo, se bypasean automáticamente:
// - Auto Gain: se fuerza a 0 (solo makeup manual)
// - Parallel Compression: se fuerza a 0 (sin compresión paralela)
// - Dry/Wet: se fuerza a 1 (100% wet)
// Esto permite escuchar SOLO la señal diferencia sin amplificaciones posteriores

// Crear valores de bypass cuando DELTA está activo
deltaBypassValue = int(0);  // Valor para forzar auto gain y parallel a 0
deltaWetValue = int(1);     // Valor para forzar dry/wet a 100% wet

// Aplicar bypass condicional basado en DELTA
//effectiveAutoGain = mix(smoothAutoGain, deltaBypassValue, smoothDeltaMode);

// Filter Order Smoothing - Suavizado de orden de filtros
smoothHpfOrder = (hpfOrderHistory * SMOOTH_HISTORY_FACTOR) + (j_HPFORDER * SMOOTH_PARAM_FACTOR);
hpfOrderHistoryNext = fixdenorm(smoothHpfOrder);
smoothLpfOrder = (lpfOrderHistory * SMOOTH_HISTORY_FACTOR) + (k_LPFORDER * SMOOTH_PARAM_FACTOR);
lpfOrderHistoryNext = fixdenorm(smoothLpfOrder);

// Variables para selección discreta de orden
hpfOrderDiscrete = 0;
lpfOrderDiscrete = 0;

// Selección discreta simplificada (solo 2 opciones)
if(smoothHpfOrder < 0.5) {
    hpfOrderDiscrete = 0;      // 12 dB/oct (0.0 - 0.49)
}
else {
    hpfOrderDiscrete = 1;      // 24 dB/oct (0.5 - 1.0)
}

if(smoothLpfOrder < 0.5) {
    lpfOrderDiscrete = 0;      // 12 dB/oct (0.0 - 0.49)
}
else {
    lpfOrderDiscrete = 1;      // 24 dB/oct (0.5 - 1.0)
}

// Delta Mode Smoothing (reemplaza a Range, mantenemos variable smoothRange de momento)
smoothRange = (rangeHistory * SMOOTH_HISTORY_FACTOR) + (h_DELTAMODE * SMOOTH_PARAM_FACTOR);
rangeHistoryNext = fixdenorm(smoothRange);

// React (Peak/RMS) Smoothing
smoothReact = (reactHistory * SMOOTH_HISTORY_FACTOR) + (g_REACT * SMOOTH_PARAM_FACTOR);
reactHistoryNext = fixdenorm(smoothReact);

// Extra Smooth Amount Smoothing
smoothSmoothAmount = (smoothAmountHistory * SMOOTH_HISTORY_FACTOR) + (z_SMOOTH * SMOOTH_PARAM_FACTOR);
smoothAmountHistoryNext = fixdenorm(smoothSmoothAmount);

// Attack Time Smoothing
smoothAttack = (atkHistory * SMOOTH_HISTORY_FACTOR) + (d_ATK * SMOOTH_PARAM_FACTOR);
atkHistoryNext = fixdenorm(smoothAttack);

// Release Time Smoothing
smoothRelease = (relHistory * SMOOTH_HISTORY_FACTOR) + (e_REL * SMOOTH_PARAM_FACTOR);
relHistoryNext = fixdenorm(smoothRelease);

// HPF Frequency Smoothing
smoothHpfFreq = (hpfFreqHistory * SMOOTH_HISTORY_FACTOR) + (j_HPF * SMOOTH_PARAM_FACTOR);
hpfFreqHistoryNext = fixdenorm(smoothHpfFreq);

// LPF Frequency Smoothing
smoothLpfFreq = (lpfFreqHistory * SMOOTH_HISTORY_FACTOR) + (k_LPF * SMOOTH_PARAM_FACTOR);
lpfFreqHistoryNext = fixdenorm(smoothLpfFreq);

// Sidechain Enable Smoothing
smoothScEnable = (scEnableHistory * SMOOTH_HISTORY_FACTOR) + (l_SC * SMOOTH_PARAM_FACTOR);
scEnableHistoryNext = fixdenorm(smoothScEnable);

// Softclip Amount Smoothing
smoothSoftclip = (softclipHistory * SMOOTH_HISTORY_FACTOR) + (u_SOFTCLIP * SMOOTH_PARAM_FACTOR);
softclipHistoryNext = fixdenorm(smoothSoftclip);

// Lookahead Smoothing (ULTRA LENTO)
smoothLookahead = (lookaheadHistory * LOOKAHEAD_SMOOTH_FACTOR) + (n_LOOKAHEAD * (1 - LOOKAHEAD_SMOOTH_FACTOR));
lookaheadHistoryNext = fixdenorm(smoothLookahead);

// =============================================================================
// LOOKAHEAD DELAY SYSTEM - Sistema de delay predictivo
// =============================================================================
// El lookahead permite al compresor "ver" la señal antes de que llegue,
// evitando transientes que causen overshooting. Las señales de audio se retrasan
// mientras que la detección trabaja con la señal sin retrasar.

// Convertir tiempo de lookahead (ms) a muestras
lookaheadSamples = mstosamps(smoothLookahead);

// Leer señales retrasadas para compresión (delayed audio)
leftDelayedForCompression = leftOutputDelay.read(lookaheadSamples, interp="step");
rightDelayedForCompression = rightOutputDelay.read(lookaheadSamples, interp="step");

// Asignar salidas de medidores principales (señales que entran a la compresión)
out4 = leftDelayedForCompression;
out5 = rightDelayedForCompression;

// Leer señales retrasadas para mezcla final (las escrituras se hacen más abajo después del trim)
leftDelayedForMixing = leftInputDelay.read(lookaheadSamples, interp="step");
rightDelayedForMixing = rightInputDelay.read(lookaheadSamples, interp="step");

// =============================================================================
// MAKEUP GAIN Y SIDECHAIN TAPS
// =============================================================================

// Makeup Gain - Ganancia de compensación
smoothMakeupGain = (makeupGainHistory * SMOOTH_HISTORY_FACTOR) + (i_MAKEUP * SMOOTH_PARAM_FACTOR);
makeupGainHistoryNext = fixdenorm(smoothMakeupGain);
// Duplicar valor para uso en canales L y R
leftMakeupGain = smoothMakeupGain;
rightMakeupGain = leftMakeupGain;

// Sidechain Tap - Señal retrasada para procesamiento de sidechain
sidechainDelayedTap = sidechainTapDelay.read(lookaheadSamples, interp="step");

// Solo Sidechain - Monitoreo de señal de sidechain
smoothSoloSidechain = (soloSidechainHistory * SMOOTH_HISTORY_FACTOR) + (m_SOLOSC * SMOOTH_PARAM_FACTOR);
soloSidechainHistoryNext = fixdenorm(smoothSoloSidechain);

// Sidechain Write Tap - Señal retrasada para escritura
sidechainDelayedWrite = sidechainWriteDelay.read(lookaheadSamples, interp="step");

// =============================================================================
// CONTROL PARAMS - Parámetros de control y bypass
// =============================================================================

// Bypass - Activación/desactivación del efecto
bypassInverted = 1 - p_BYPASS;               // Invertir lógica (1=activo, 0=bypass)
smoothBypassAmount = (bypassAmountHistory * SMOOTH_HISTORY_FACTOR) + (bypassInverted * SMOOTH_PARAM_FACTOR);
bypassAmountHistoryNext = fixdenorm(smoothBypassAmount);

// Key Mix - Mezcla entre señal principal y external key
smoothKeyMix = (keyMixHistory * SMOOTH_HISTORY_FACTOR) + (r_KEY * SMOOTH_PARAM_FACTOR);
keyMixHistoryNext = fixdenorm(smoothKeyMix);

// Dry/Wet Mix - Balance entre señal original y procesada
smoothDryWetMix = (dryWetMixHistory * SMOOTH_HISTORY_FACTOR) + (o_DRYWET * SMOOTH_PARAM_FACTOR);
dryWetMixHistoryNext = fixdenorm(smoothDryWetMix);

// Aplicar bypass de dry/wet cuando DELTA está activo
effectiveDryWetMix = mix(smoothDryWetMix, deltaWetValue, smoothDeltaMode);

// =============================================================================
// INPUT PROCESSING - Procesamiento de entradas con trim
// =============================================================================
// Trim Principal - Ganancia de entrada
smoothTrimGain = (trimHistory * SMOOTH_HISTORY_FACTOR) + (a_TRIM * SMOOTH_PARAM_FACTOR);
trimHistoryNext = fixdenorm(smoothTrimGain);
trimGainLinear = dbtoa(smoothTrimGain);

// Aplicar trim a entradas
leftTrimmed = in1 * trimGainLinear;
rightTrimmed = in2 * trimGainLinear;

// Escribir señales en delays
leftInputDelay.write(in1);          // Sin trim para bypass/dry
rightInputDelay.write(in2);         // Sin trim para bypass/dry
leftOutputDelay.write(leftTrimmed); // Con trim para compresión
rightOutputDelay.write(rightTrimmed); // Con trim para compresión

// Crear señal mono de entrada principal
mainSignalMono = ((rightTrimmed + leftTrimmed)) * 0.707;  // Suma mono de entrada principal
trimGainReference = trimGainLinear;           // Referencia para normalización posterior

// Sidechain Trim - Ganancia de entrada de sidechain
smoothSidechainTrimGain = (sidechainTrimHistory * SMOOTH_HISTORY_FACTOR) + (y_SCTRIM * SMOOTH_PARAM_FACTOR);
sidechainTrimHistoryNext = fixdenorm(smoothSidechainTrimGain);
sidechainTrimGainLinear = dbtoa(smoothSidechainTrimGain);
sidechainTrimReference = sidechainTrimGainLinear;  // Referencia para uso posterior

// Aplicar trim a entradas de sidechain
leftSidechainTrimmed = in3 * sidechainTrimReference;
rightSidechainTrimmed = in4 * sidechainTrimReference;

// Asignar salidas de sidechain (sin delay por ahora)
out6 = leftSidechainTrimmed;
out7 = rightSidechainTrimmed;

// Crear señal mono de sidechain
sidechainSignalMono = ((rightSidechainTrimmed + leftSidechainTrimmed)) * 0.707;  // Suma mono de sidechain

// Key mixing - Mezcla entre señal principal y external key input
keyMixedSignal = mix(mainSignalMono, sidechainSignalMono, smoothKeyMix);

// Control params asignados directamente
ONSIDECHAIN = smoothScEnable;
REACT = smoothReact;

//AUTO_RELEASE = s_AUTORELEASE;  // Directo, sin SPEED

EXTRA_SMOOTH = smoothSmoothAmount;

// =============================================================================
// FILTROS DE SIDECHAIN - BIQUAD BUTTERWORTH (Robert Bristow-Johnson)
// =============================================================================
// Implementación de filtros biquad de 2º orden (12 dB/oct) con opción de
// cascadear para 4º orden (24 dB/oct). Transición suave entre órdenes.
// Basado en las fórmulas de Robert Bristow-Johnson's Audio EQ Cookbook

// Variables de salida de filtros
lpfFinalSignal = 0;
hpfFinalSignal = 0;

// Q factor para respuesta Butterworth (maximally flat)
BUTTERWORTH_Q = 1.0;                         // Q = 1 para respuesta plana sin resonancia

// Coeficientes LPF Butterworth de 2º orden
omega = ((smoothLpfFreq * twopi)) / samplerate;   // Frecuencia normalizada
sn = sin(omega);
cs = cos(omega);
one_over_Q = 1 / BUTTERWORTH_Q;              // Inverso del Q factor
alpha = ((sn * 0.5)) * one_over_Q;
b0 = 1 / ((1 + alpha));                     // Normalización
a2 = ((((1 - cs)) * 0.5)) * b0;             // Coeficiente feedforward z^-2
a1 = ((1 - cs)) * b0;                       // Coeficiente feedforward z^-1
b1 = ((-2 * cs)) * b0;                      // Coeficiente feedback z^-1
b2 = ((1 - alpha)) * b0;                    // Coeficiente feedback z^-2

// Asignar coeficientes LPF
lpfCoeffA2 = a2;
lpfCoeffA1 = a1;
lpfCoeffA0 = a2;  // a0 = a2 para LPF simétrico
lpfCoeffB1 = b1;
lpfCoeffB2 = b2;

// Coeficientes HPF Butterworth de 2º orden
omega_hpf = ((smoothHpfFreq * twopi)) / samplerate;
sn_hpf = sin(omega_hpf);
cs_hpf = cos(omega_hpf);
alpha_hpf = ((sn_hpf * 0.5)) / BUTTERWORTH_Q;  // Usar mismo Q factor
b0_hpf = 1 / ((1 + alpha_hpf));
a_hpf = ((((1 + cs_hpf)) * 0.5)) * b0_hpf;   // Coeficiente feedforward
a_neg_hpf = (-(1 + cs_hpf)) * b0_hpf;       // Coeficiente feedforward negativo
b1_hpf = ((-2 * cs_hpf)) * b0_hpf;
b2_hpf = ((1 - alpha_hpf)) * b0_hpf;

// Asignar coeficientes HPF
hpfCoeffA2 = a_hpf;
hpfCoeffA1 = a_neg_hpf;
hpfCoeffA0 = a_hpf;  // a0 = a2 para HPF simétrico
hpfCoeffB1 = b1_hpf;
hpfCoeffB2 = b2_hpf;

// Pre-procesar señal de sidechain
sidechainMixedSignal = keyMixedSignal * 0.707;

// =============================================================================
// LPF - FILTRO PASO BAJO CON OPCIÓN 12/24 dB/oct
// =============================================================================

// Primera etapa LPF (12 dB/oct)
lpfInput = sidechainMixedSignal * lpfCoeffA2;
lpfFromHistory1 = lpfHistory3 * lpfCoeffA1;
lpfFromHistory2 = lpfHistory1 * lpfCoeffA0;
lpfFeedback1 = lpfHistory2 * lpfCoeffB2;
lpfFeedback2 = lpfHistory4 * lpfCoeffB1;
lpfFilteredSignal = ((((lpfFromHistory2 + lpfFromHistory1)) + lpfInput)) - ((lpfFeedback2 + lpfFeedback1));

// Actualizar historias LPF primera etapa
lpfHistory1Next = fixdenorm(lpfHistory3);
lpfHistory2Next = fixdenorm(lpfHistory4);
lpfHistory3Next = fixdenorm(sidechainMixedSignal);
lpfHistory4Next = fixdenorm(lpfFilteredSignal);

// Segunda etapa LPF (para 24 dB/oct)
lpfStage2Input = lpfFilteredSignal * lpfCoeffA2;
lpfStage2FromHistory1 = lpfHistory7 * lpfCoeffA1;
lpfStage2FromHistory2 = lpfHistory5 * lpfCoeffA0;
lpfStage2Feedback1 = lpfHistory6 * lpfCoeffB2;
lpfStage2Feedback2 = lpfHistory8 * lpfCoeffB1;
lpfStage2FilteredSignal = ((((lpfStage2FromHistory2 + lpfStage2FromHistory1)) + lpfStage2Input)) - ((lpfStage2Feedback2 + lpfStage2Feedback1));

// Actualizar historias LPF segunda etapa
lpfHistory5Next = fixdenorm(lpfHistory7);
lpfHistory6Next = fixdenorm(lpfHistory8);
lpfHistory7Next = fixdenorm(lpfFilteredSignal);
lpfHistory8Next = fixdenorm(lpfStage2FilteredSignal);

// Tercera etapa LPF (mantenida para compatibilidad pero no usada para 12/24 dB/oct)
lpfStage3Input = lpfStage2FilteredSignal * lpfCoeffA2;
lpfStage3FromHistory1 = lpfHistory11 * lpfCoeffA1;
lpfStage3FromHistory2 = lpfHistory9 * lpfCoeffA0;
lpfStage3Feedback1 = lpfHistory10 * lpfCoeffB2;
lpfStage3Feedback2 = lpfHistory12 * lpfCoeffB1;
lpfStage3FilteredSignal = ((((lpfStage3FromHistory2 + lpfStage3FromHistory1)) + lpfStage3Input)) - ((lpfStage3Feedback2 + lpfStage3Feedback1));

// Actualizar historias LPF tercera etapa
lpfHistory9Next = fixdenorm(lpfHistory11);
lpfHistory10Next = fixdenorm(lpfHistory12);
lpfHistory11Next = fixdenorm(lpfStage2FilteredSignal);
lpfHistory12Next = fixdenorm(lpfStage3FilteredSignal);

// Cuarta etapa LPF (mantenida para compatibilidad pero no usada para 12/24 dB/oct)
lpfStage4Input = lpfStage3FilteredSignal * lpfCoeffA2;
lpfStage4FromHistory1 = lpfHistory15 * lpfCoeffA1;
lpfStage4FromHistory2 = lpfHistory13 * lpfCoeffA0;
lpfStage4Feedback1 = lpfHistory14 * lpfCoeffB2;
lpfStage4Feedback2 = lpfHistory16 * lpfCoeffB1;
lpfStage4FilteredSignal = ((((lpfStage4FromHistory2 + lpfStage4FromHistory1)) + lpfStage4Input)) - ((lpfStage4Feedback2 + lpfStage4Feedback1));

// Actualizar historias LPF cuarta etapa
lpfHistory13Next = fixdenorm(lpfHistory15);
lpfHistory14Next = fixdenorm(lpfHistory16);
lpfHistory15Next = fixdenorm(lpfStage3FilteredSignal);
lpfHistory16Next = fixdenorm(lpfStage4FilteredSignal);

// LPF - Seleccionar salida según orden (solo 12 o 24 dB/oct)
if(lpfOrderDiscrete == 0) {
    lpfFinalSignal = lpfFilteredSignal;           // 12 dB/oct (solo etapa 1)
}
else {
    lpfFinalSignal = lpfStage2FilteredSignal;     // 24 dB/oct (etapas 1+2)
}

// Mezclar señal directa con LPF según ONSIDECHAIN
lpfMixedSignal = mix(sidechainMixedSignal, lpfFinalSignal, ONSIDECHAIN);

// =============================================================================
// HPF - FILTRO PASO ALTO CON OPCIÓN 12/24 dB/oct
// =============================================================================

// Primera etapa HPF (12 dB/oct)
hpfInput = lpfMixedSignal * hpfCoeffA2;
hpfFromHistory1 = hpfHistory3 * hpfCoeffA1;
hpfFromHistory2 = hpfHistory2 * hpfCoeffA0;
hpfFeedback1 = hpfHistory1 * hpfCoeffB2;
hpfFeedback2 = hpfHistory4 * hpfCoeffB1;
hpfFilteredSignal = ((((hpfFromHistory2 + hpfFromHistory1)) + hpfInput)) - ((hpfFeedback2 + hpfFeedback1));

// Actualizar historias HPF primera etapa
hpfHistory1Next = fixdenorm(hpfHistory4);
hpfHistory2Next = fixdenorm(hpfHistory3);
hpfHistory3Next = fixdenorm(lpfMixedSignal);
hpfHistory4Next = fixdenorm(hpfFilteredSignal);

// Segunda etapa HPF (para 24 dB/oct)
hpfStage2Input = hpfFilteredSignal * hpfCoeffA2;
hpfStage2FromHistory1 = hpfHistory7 * hpfCoeffA1;
hpfStage2FromHistory2 = hpfHistory6 * hpfCoeffA0;
hpfStage2Feedback1 = hpfHistory5 * hpfCoeffB2;
hpfStage2Feedback2 = hpfHistory8 * hpfCoeffB1;
hpfStage2FilteredSignal = ((((hpfStage2FromHistory2 + hpfStage2FromHistory1)) + hpfStage2Input)) - ((hpfStage2Feedback2 + hpfStage2Feedback1));

// Actualizar historias HPF segunda etapa
hpfHistory5Next = fixdenorm(hpfHistory8);
hpfHistory6Next = fixdenorm(hpfHistory7);
hpfHistory7Next = fixdenorm(hpfFilteredSignal);
hpfHistory8Next = fixdenorm(hpfStage2FilteredSignal);

// Tercera etapa HPF (mantenida para compatibilidad pero no usada para 12/24 dB/oct)
hpfStage3Input = hpfStage2FilteredSignal * hpfCoeffA2;
hpfStage3FromHistory1 = hpfHistory11 * hpfCoeffA1;
hpfStage3FromHistory2 = hpfHistory10 * hpfCoeffA0;
hpfStage3Feedback1 = hpfHistory9 * hpfCoeffB2;
hpfStage3Feedback2 = hpfHistory12 * hpfCoeffB1;
hpfStage3FilteredSignal = ((((hpfStage3FromHistory2 + hpfStage3FromHistory1)) + hpfStage3Input)) - ((hpfStage3Feedback2 + hpfStage3Feedback1));

// Actualizar historias HPF tercera etapa
hpfHistory9Next = fixdenorm(hpfHistory12);
hpfHistory10Next = fixdenorm(hpfHistory11);
hpfHistory11Next = fixdenorm(hpfStage2FilteredSignal);
hpfHistory12Next = fixdenorm(hpfStage3FilteredSignal);

// Cuarta etapa HPF (mantenida para compatibilidad pero no usada para 12/24 dB/oct)
hpfStage4Input = hpfStage3FilteredSignal * hpfCoeffA2;
hpfStage4FromHistory1 = hpfHistory15 * hpfCoeffA1;
hpfStage4FromHistory2 = hpfHistory14 * hpfCoeffA0;
hpfStage4Feedback1 = hpfHistory13 * hpfCoeffB2;
hpfStage4Feedback2 = hpfHistory16 * hpfCoeffB1;
hpfStage4FilteredSignal = ((((hpfStage4FromHistory2 + hpfStage4FromHistory1)) + hpfStage4Input)) - ((hpfStage4Feedback2 + hpfStage4Feedback1));

// Actualizar historias HPF cuarta etapa
hpfHistory13Next = fixdenorm(hpfHistory16);
hpfHistory14Next = fixdenorm(hpfHistory15);
hpfHistory15Next = fixdenorm(hpfStage3FilteredSignal);
hpfHistory16Next = fixdenorm(hpfStage4FilteredSignal);

// HPF - Seleccionar salida según orden (solo 12 o 24 dB/oct)
if(hpfOrderDiscrete == 0) {
    hpfFinalSignal = hpfFilteredSignal;           // 12 dB/oct (solo etapa 1)
}
else {
    hpfFinalSignal = hpfStage2FilteredSignal;     // 24 dB/oct (etapas 1+2)
}

// Mezclar señal con HPF según ONSIDECHAIN y obtener señal final de sidechain
sidechainProcessedSignal = mix(lpfMixedSignal, hpfFinalSignal, ONSIDECHAIN);
sidechainDetectionSignal = sidechainProcessedSignal;

// =============================================================================
// DETECCIÓN DE ENVOLVENTE - Sistema 1 algoritmo sharp
// =============================================================================
// Los algoritmos y su hibridación han sido elegidos empíricamente por oído

// Detección de envolvente - Preparación de coeficientes
attack_ms = max(0.05, smoothAttack);
release_ms = max(0.1, smoothRelease);
attack_coeff = exp(-1 / ((((attack_ms * samplerate)) * 0.001)));
release_coeff = exp(-1 / ((((release_ms * samplerate)) * 0.001)));

// =============================================================================
// RMS SHARP (para ALGO 0) - Sliding RMS con ventana corta
// =============================================================================
rms_window = max(1, floor(25 * (samplerate / 48000)));  // Escalar ventana por SR
rms_window_inv = 1 / rms_window;                        // Precalcular inverso
input_squared = sidechainDetectionSignal * sidechainDetectionSignal;
oldest_sq = rmsDelay.read(rms_window, interp="none");   // Leer muestra más antigua
rms_sum_new = ((input_squared + rmsSum)) - oldest_sq;   // Cálculo incremental
rms_sum_clipped = max(0, rms_sum_new);                  // Evitar valores negativos
rms_value_sharp = sqrt(rms_sum_clipped * rms_window_inv); // RMS final
rmsSum = rms_sum_clipped;                               // Actualizar suma
rmsDelay.write(input_squared);                          // Escribir nueva muestra

// =============================================================================
// ALGORITMO 0: SHARP DETECTOR - Respuesta rápida y precisa CON HOLD
// =============================================================================
peakEnvSharp = abs(sidechainDetectionSignal);
env_mix_sharp = mix(peakEnvSharp, rms_value_sharp, REACT);
release_env_175 = releaseHistSharp * release_coeff;
env_post_release_176 = max(env_mix_sharp, release_env_175);

// HOLD - Mantener el nivel por el tiempo especificado
hold_samples = mstosamps(f_HOLD);
hold_env_sharp = env_post_release_176;  // Por defecto usar el valor actual

if(env_post_release_176 > held_peak_sharp) {
    // La señal subió - actualizar pico y resetear contador
    held_peak_sharp = env_post_release_176;
    hold_counter_sharp = 0;
    hold_env_sharp = held_peak_sharp;
}
else {
    // La señal bajó - verificar si estamos en hold
    hold_counter_sharp = min(hold_counter_sharp + 1, hold_samples);
    if(hold_counter_sharp < hold_samples) {
        // Aún en hold - mantener el nivel pico Y congelar el release
        hold_env_sharp = held_peak_sharp;
        env_post_release_176 = held_peak_sharp;  // IMPORTANTE: Congelar el release
    }
    else {
        // Hold terminado - permitir que caiga
        hold_env_sharp = env_post_release_176;
        held_peak_sharp = env_post_release_176;
    }
}

// Aplicar attack usando el valor con hold
attack_env_177 = attackHistSharp * attack_coeff;
attack_mix_178 = (((1 - attack_coeff)) * hold_env_sharp) + (attack_coeff * attack_env_177);
sharpEnvelopeFinal = max(attack_mix_178, 1e-06);
releaseHistSharp = fixdenorm(env_post_release_176);
attackHistSharp = fixdenorm(attack_mix_178);

// =============================================================================
// EXTRA SMOOTHING POST-DETECCIÓN - Suavizado adicional configurable
// =============================================================================
smooth_amount_shaped = pow(EXTRA_SMOOTH, 2.5);         // Curva exponencial para control musical
smooth_time_ms = mix(0.001, 100, smooth_amount_shaped); // Mapeo a rango temporal
extra_smooth_coeff = exp(-1 / ((((smooth_time_ms * samplerate)) * 0.001))); // Coeficiente de filtro

// Algoritmo 0 - Salida en dB con smoothing opcional
expr_algo0 = atodb(sharpEnvelopeFinal);               // Conversión a dB base
if(EXTRA_SMOOTH >= 0.001) {                           // Solo si hay smoothing significativo
    extraSmoothedSharpEnv = (extraSmoothHistSharp * extra_smooth_coeff) + (sharpEnvelopeFinal * ((1 - extra_smooth_coeff)));
    extraSmoothHistSharp = fixdenorm(extraSmoothedSharpEnv);
    expr_algo0 = atodb(max(extraSmoothedSharpEnv, 1e-06)); // Evitar log(0)
}

// =============================================================================
// SELECTOR Y MORPHING DE ALGORITMOS - Transición continua sin saltos
// =============================================================================

// Usar directamente la salida del algoritmo Sharp
envelopeDetectorOutput = expr_algo0;  // Solo Sharp
finalEnvelopeDb = envelopeDetectorOutput;

// =============================================================================
// COMPENSACIÓN DE GANANCIA PARA SOLO SIDECHAIN - Evitar saltos abruptos
// =============================================================================
unitaryReference = int(1);                           // Valor de referencia unitario
trimCompensationFactor = unitaryReference / trimGainReference; // Factor de compensación inverso al trim
sidechainTrimCompensated = sidechainDetectionSignal * trimCompensationFactor; // Aplicar compensación de trim
normalizedSidechainSignal = sidechainTrimCompensated; // Señal compensada para monitoreo

// =============================================================================
// PROCESAMIENTO DE SALIDA - Canal Izquierdo - VERSIÓN COMPLETA MEJORADA
// =============================================================================

// DETECCIÓN DE TRANSIENTES MEJORADA
envelope_linear = dbtoa(finalEnvelopeDb);

// Derivada con suavizado previo para reducir ruido
//envelope_smoothed = (envelopeHistory * 0.9) + (envelope_linear * 0.1);

// Suavizado dinámico del envelope basado en EXTRA_SMOOTH
//envelope_smooth_amount = mix(0.05, 0.95, smoothSmoothAmount);  // 5% a 95% de smoothing

// envelope_smooth_amount = mix(0.001, 0.01, smoothSmoothAmount);  // la que más me convence

// prueba exponencial (más musical)
smooth_shaped = pow(smoothSmoothAmount, 2);  // Curva cuadrática
envelope_smooth_amount = mix(0.05, 0.7, smooth_shaped);
// de momento me quedo con esta

envelope_smoothed = (envelopeHistory * envelope_smooth_amount) + (envelope_linear * (1 - envelope_smooth_amount));
envelope_change = envelope_smoothed - envelopeHistory;
envelopeHistory = envelope_smoothed;

// Rectificar y escalar la derivada con SENSITIVITY - RANGO AMPLIADO
// 0 = muy selectivo (solo picos fuertes), 1 = muy sensible (detecta todo)
sensitivity_scale = scale(smoothSensitivity, 0, 1, 1, 500);  // 1x a 20x (más musical)
positive_change = max(0, envelope_change * sensitivity_scale);

// Ajustar también el umbral según sensitivity para mejor control
// Con baja sensitivity, umbral más alto (más selectivo)
threshold_scale = scale(smoothSensitivity, 0, 1, 0.05, 0.001);
threshold = threshold_scale + (envelope_smoothed * 0.01);
is_attack = positive_change > threshold ? 1 : 0;

// Suavizado dinámico basado en los parámetros de timing
detection_attack_coeff = exp(-1 / (max(0.5, smoothAttack * 0.1) * samplerate * 0.001));
detection_release_coeff = exp(-1 / (max(5, smoothRelease * 0.5) * samplerate * 0.001));

// Declarar attack_env e inicializar
attack_env = 0;

if(is_attack > 0.5) {
    attack_env = (transientSmoothHistory * detection_attack_coeff) + (is_attack * (1 - detection_attack_coeff));
} else {
    attack_env = (transientSmoothHistory * detection_release_coeff) + (is_attack * (1 - detection_release_coeff));
}

transientSmoothHistory = attack_env;

// Limitar envolvente de attack para evitar sobre-modulación
attack_env = min(attack_env, 1);

// ENVOLVENTE DE SUSTAIN MEJORADA - Más independiente
// Sustain solo activo cuando NO hay transiente
//sustain_active = 1 - min(attack_env * 2, 1);  // Corte más agresivo
sustain_active = 1 - pow(min(attack_env * 1.5, 1), 0.7);  // Curva más suave y musical
sustain_env = sustain_active;

// APLICAR GANANCIAS CON CURVA SUAVE
// Convertir controles a factores lineales con curva
attack_factor = pow(dbtoa(smoothAttackGain), 0.7);  // con 0.3 - 0.5 - 0.825 1.0
sustain_factor = pow(dbtoa(smoothSustainGain), 0.7);

// Calcular ganancia total con mezcla ponderada
gain_from_attack = mix(1, attack_factor, attack_env);
gain_from_sustain = mix(1, sustain_factor, sustain_env);

// Combinar ambas ganancias
gain_total = gain_from_attack * gain_from_sustain;
gain_total = max(0.1, min(10, gain_total));  // Limitar entre -20dB y +20dB

// Aplicar a la señal
expandedLeft = leftDelayedForCompression * gain_total;

// MODO DELTA MEJORADO - Con transición suave entre modos
delta_control = clamp(smoothDeltaMode, 0, 1);
delta_signal = 0;
unprocessed = 0;

// Para modo DELTA: usar DELTAMODE con transición suave
if(delta_control > 0.01) {
    delta_mode = smoothRange;  // 0-2
    
    // Calcular las tres posibles señales delta
    // 1. Attack only
    gain_attack_only = mix(1, attack_factor, attack_env);
    delta_attack_only = (leftDelayedForCompression * gain_attack_only) - leftDelayedForCompression;
    
    // 2. Sustain only
    gain_sustain_only = mix(1, sustain_factor, sustain_env);
    delta_sustain_only = (leftDelayedForCompression * gain_sustain_only) - leftDelayedForCompression;
    
    // 3. Both (completo)
    delta_both = expandedLeft - leftDelayedForCompression;
    
    // Hacer morphing suave entre los modos
    if(delta_mode <= 1) {
        // Transición de Attack (0) a Both (1)
        fade = delta_mode;  // 0 a 1
        delta_signal = mix(delta_attack_only, delta_both, fade);
    } else {
        // Transición de Both (1) a Sustain (2)
        fade = delta_mode - 1;  // 0 a 1
        delta_signal = mix(delta_both, delta_sustain_only, fade);
    }
}

leftWithDelta = mix(expandedLeft, delta_signal, delta_control);

// AUTO MAKEUP - Compensación automática de ganancia (70% del gain reduction)
autoMakeupGainReduction = 0;  // No hay gain reduction en transient designer
reduction_smooth_mul = reductionHistLeft * SMOOTH_HISTORY_FACTOR;
reduction_current_mul = autoMakeupGainReduction * SMOOTH_PARAM_FACTOR;
reduction_smoothed = reduction_current_mul + reduction_smooth_mul;
auto_makeup = reduction_smoothed * AUTO_MAKEUP_FACTOR;
combined_makeup = auto_makeup + leftMakeupGain;

final_makeup_db = leftMakeupGain;

// Cuando DELTA está activo, forzar makeup a 0dB
finalMakeupDbWithDelta = mix(final_makeup_db, 0, smoothDeltaMode);
makeup_linear = dbtoa(finalMakeupDbWithDelta);
leftWithMakeup = leftWithDelta * makeup_linear;
reductionHistLeft = fixdenorm(reduction_smoothed);

// Sin compresión paralela - pasar directamente la señal procesada
leftParallelMixed = leftWithMakeup;

// MIX DRY/WET - Balance entre señal original y procesada
leftDryWetMixed = mix(leftDelayedForMixing, leftParallelMixed, effectiveDryWetMix);
leftWithSidechain = mix(leftDryWetMixed, sidechainDelayedWrite, smoothSoloSidechain);

// OUTPUT PROCESSING - Saturación asimétrica (Off/Soft)
maxOutput = 0.989;
saturationAmount = clamp(smoothSoftclip, 0, 1);
effectiveSaturationAmount = mix(saturationAmount, 0, smoothDeltaMode);

// Saturación asimétrica para añadir color/calidez
leftSaturated = 0;
if(leftWithSidechain > 0) {
    leftSaturated = tanh(leftWithSidechain * 1.2) * 0.833;
}
else {
    leftSaturated = tanh(leftWithSidechain * 0.8) * 1.25;
}
leftSaturated = clamp(leftSaturated, -maxOutput, maxOutput);

// Mezclar señal original con saturada según el parámetro
leftProcessedOutput = mix(leftWithSidechain, leftSaturated, effectiveSaturationAmount);
leftFinalOutput = mix(leftDelayedForMixing, leftProcessedOutput, smoothBypassAmount);
out1 = leftFinalOutput;

// =============================================================================
// PROCESAMIENTO DE SALIDA - Canal Derecho
// =============================================================================
// Idéntico al canal izquierdo pero con variables propias para claridad.

// Usar los valores ya calculados del canal izquierdo
rightGainTotal = gain_total;  // La ganancia es la misma para ambos canales
expandedRight = rightDelayedForCompression * rightGainTotal;

// MODO DELTA MEJORADO - Con transición suave entre modos (Canal Derecho)
rightDeltaControl = clamp(smoothDeltaMode, 0, 1);
rightDeltaSignal = 0;
rightUnprocessed = 0;

// Para modo DELTA: usar DELTAMODE con transición suave
if(rightDeltaControl > 0.01) {
    right_delta_mode = smoothRange;  // 0-2
    
    // Calcular las tres posibles señales delta
    // 1. Attack only
    right_gain_attack_only = mix(1, attack_factor, attack_env);
    right_delta_attack_only = (rightDelayedForCompression * right_gain_attack_only) - rightDelayedForCompression;
    
    // 2. Sustain only
    right_gain_sustain_only = mix(1, sustain_factor, sustain_env);
    right_delta_sustain_only = (rightDelayedForCompression * right_gain_sustain_only) - rightDelayedForCompression;
    
    // 3. Both (completo)
    right_delta_both = expandedRight - rightDelayedForCompression;
    
    // Hacer morphing suave entre los modos
    if(right_delta_mode <= 1) {
        // Transición de Attack (0) a Both (1)
        right_fade = right_delta_mode;  // 0 a 1
        rightDeltaSignal = mix(right_delta_attack_only, right_delta_both, right_fade);
    } else {
        // Transición de Both (1) a Sustain (2)
        right_fade = right_delta_mode - 1;  // 0 a 1
        rightDeltaSignal = mix(right_delta_both, right_delta_sustain_only, right_fade);
    }
}

rightWithDelta = mix(expandedRight, rightDeltaSignal, rightDeltaControl);

// AUTO MAKEUP - Compensación automática de ganancia
rightAutoMakeupGainReduction = 0;  // No hay gain reduction en transient designer
rightReductionSmoothMul = reductionHistRight * SMOOTH_HISTORY_FACTOR;
rightReductionCurrentMul = rightAutoMakeupGainReduction * SMOOTH_PARAM_FACTOR;
rightReductionSmoothed = rightReductionCurrentMul + rightReductionSmoothMul;
rightAutoMakeup = rightReductionSmoothed * AUTO_MAKEUP_FACTOR;
rightCombinedMakeup = rightAutoMakeup + rightMakeupGain;

rightFinalMakeupDb = rightMakeupGain;

// Cuando DELTA está activo, forzar makeup a 0dB
rightFinalMakeupDbWithDelta = mix(rightFinalMakeupDb, 0, smoothDeltaMode);
rightMakeupLinear = dbtoa(rightFinalMakeupDbWithDelta);
rightWithMakeup = rightWithDelta * rightMakeupLinear;
reductionHistRight = fixdenorm(rightReductionSmoothed);

// Sin compresión paralela - pasar directamente la señal procesada
rightParallelMixed = rightWithMakeup;

// MIX DRY/WET - Balance entre señal original y procesada
rightDryWetMixed = mix(rightDelayedForMixing, rightParallelMixed, effectiveDryWetMix);
rightWithSidechain = mix(rightDryWetMixed, sidechainDelayedTap, smoothSoloSidechain);

// OUTPUT PROCESSING - Saturación asimétrica (Off/Soft)
rightSaturationAmount = clamp(smoothSoftclip, 0, 1);
rightEffectiveSaturationAmount = mix(rightSaturationAmount, 0, smoothDeltaMode);

// Saturación asimétrica para añadir color/calidez
rightSaturated = 0;
if(rightWithSidechain > 0) {
    rightSaturated = tanh(rightWithSidechain * 1.2) * 0.833;
}
else {
    rightSaturated = tanh(rightWithSidechain * 0.8) * 1.25;
}
rightSaturated = clamp(rightSaturated, -maxOutput, maxOutput);

// Mezclar señal original con saturada según el parámetro
rightProcessedOutput = mix(rightWithSidechain, rightSaturated, rightEffectiveSaturationAmount);
rightFinalOutput = mix(rightDelayedForMixing, rightProcessedOutput, smoothBypassAmount);
out2 = rightFinalOutput;

// =============================================================================
// GAIN REDUCTION OUTPUT - Medidor bipolar -1 a +1 para UI (escala lineal)
// =============================================================================
// Medidor intuitivo con escala lineal para mejor respuesta visual

// Mapear ganancia lineal al rango -1 a +1
// gain_total = 0.25 (-12dB) a 4.0 (+12dB), centro = 1.0
gain_meter_bipolar = 0;

if(gain_total >= 1) {
    // Amplificación: mapear 1-4 a 0-1
    gain_meter_bipolar = (gain_total - 1) / 3;
} else {
    // Atenuación: mapear 0.25-1 a -1-0
    gain_meter_bipolar = (gain_total - 1) / 0.75;
}

gain_meter_bipolar = clamp(gain_meter_bipolar, -1, 1);

gainReductionMeter = mix(0, gain_meter_bipolar, bypassInverted);
gainReductionOutput = gainReductionMeter;
out3 = gainReductionOutput;

// =============================================================================
// ACTUALIZACIÓN DE HISTORIAS PARA EL SIGUIENTE CICLO
// =============================================================================
// Todas las historias se actualizan al final del ciclo de procesamiento

// Historias de smoothing de parámetros
deltaModeHistory = deltaModeHistoryNext;
attackGainHistory = attackGainHistoryNext;    // NUEVA
sustainGainHistory = sustainGainHistoryNext;  // NUEVA
sensitivityHistory = sensitivityHistoryNext;  // NUEVA

makeupGainHistory = makeupGainHistoryNext;
soloSidechainHistory = soloSidechainHistoryNext;
bypassAmountHistory = bypassAmountHistoryNext;
keyMixHistory = keyMixHistoryNext;
dryWetMixHistory = dryWetMixHistoryNext;
trimHistory = trimHistoryNext;
sidechainTrimHistory = sidechainTrimHistoryNext;

// Historias adicionales de smoothing
rangeHistory = rangeHistoryNext;
reactHistory = reactHistoryNext;
smoothAmountHistory = smoothAmountHistoryNext;
lookaheadHistory = lookaheadHistoryNext;
hpfFreqHistory = hpfFreqHistoryNext;
lpfFreqHistory = lpfFreqHistoryNext;
scEnableHistory = scEnableHistoryNext;
softclipHistory = softclipHistoryNext;
atkHistory = atkHistoryNext;
relHistory = relHistoryNext;

// Historias de filtros LPF (etapas 1-4)
lpfHistory1 = lpfHistory1Next;
lpfHistory2 = lpfHistory2Next;
lpfHistory3 = lpfHistory3Next;
lpfHistory4 = lpfHistory4Next;
lpfHistory5 = lpfHistory5Next;
lpfHistory6 = lpfHistory6Next;
lpfHistory7 = lpfHistory7Next;
lpfHistory8 = lpfHistory8Next;
lpfHistory9 = lpfHistory9Next;
lpfHistory10 = lpfHistory10Next;
lpfHistory11 = lpfHistory11Next;
lpfHistory12 = lpfHistory12Next;
lpfHistory13 = lpfHistory13Next;
lpfHistory14 = lpfHistory14Next;
lpfHistory15 = lpfHistory15Next;
lpfHistory16 = lpfHistory16Next;

// Historias de filtros HPF (etapas 1-4)
hpfHistory1 = hpfHistory1Next;
hpfHistory2 = hpfHistory2Next;
hpfHistory3 = hpfHistory3Next;
hpfHistory4 = hpfHistory4Next;
hpfHistory5 = hpfHistory5Next;
hpfHistory6 = hpfHistory6Next;
hpfHistory7 = hpfHistory7Next;
hpfHistory8 = hpfHistory8Next;
hpfHistory9 = hpfHistory9Next;
hpfHistory10 = hpfHistory10Next;
hpfHistory11 = hpfHistory11Next;
hpfHistory12 = hpfHistory12Next;
hpfHistory13 = hpfHistory13Next;
hpfHistory14 = hpfHistory14Next;
hpfHistory15 = hpfHistory15Next;
hpfHistory16 = hpfHistory16Next;

// Historias de orden de filtros
hpfOrderHistory = hpfOrderHistoryNext;
lpfOrderHistory = lpfOrderHistoryNext;

// Delays de lookahead (escritura para el siguiente ciclo)
sidechainWriteDelay.write(normalizedSidechainSignal);
sidechainTapDelay.write(normalizedSidechainSignal);
// Las escrituras de leftOutputDelay y rightOutputDelay se hacen ahora arriba con el trim